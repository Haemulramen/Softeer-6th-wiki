# 소프티어 1주차 목요일 회고
2025년 07월 10일

### 진행 중인 과제
> 웹 서버 1단계 - index.html 응답
> 
> 웹 서버 2단계 - 다양한 컨텐츠 타입 지원

### 과제를 하며...
1. **TCP 연결을 종료하면서 자원을 어떻게 관리하는 것이 좋은가?**
   - 아침에 그룹원과의 자원 해제와 관련한 토의 과정에서 "소멸자"라는 키워드를 얻을 수 있었다. 
     하지만 조금 더 알아본 결과 finalize(), cleaner를 통한 자원해제는 위험하고 예측 불가능하다는 결론에 도달할 수 있었다.
   - Java에서 finalize()는 GC(Garbage Collection) 시점에 호출되며, 이 시점이 언제가 될 지 보장할 수 없기 때문에 오히려 자원 누수의 위험이 생긴다는 것이다.
     따라서 인스턴스 사용을 하고 나서 명시적인 close() 메서드를 호출하거나 try-with-resource 구문을 사용하는 것이 좋다.
     
2. **Keep-alive 기능을 구현할 때 어떻게 소켓 연결을 유지할까?**
   - Keep-alive 기능을 구현하는 것은 응답 헤더에 `Connection: keep-alive`와 `Keep-Alive: timeout=5, max=100` 필드를 추가해서 해결할 수 있었다.
     문제는 "소켓 연결을 어떻게 유지할 것인가"였다.
   - 이 문제를 해결하기 위해서 고민한 결과 무한 반복에서 켓 연결이 종료되었을 때 발생하는 SocketTimeoutException을 catch해서 탈출하는 방식으로 해결할 수 있었다.
   - 여기서 하나 더 체크해보고 싶었던 부분은 실제 HTTP에서 keep-alive의 동작이 어떻게 되는지였다. 
     내가 구현한 바에 의하면 매번 새로운 요청이 들어올 때마다 소켓 연결의 수명을 5초로 재설정하고 있었는데,
     실제 HTTP 연결에서 처음 서버와 클라이언트가 연결된 시점부터 단 5초 동안만 연결을 유지한다면 그에 맞게 수정하고 싶었기 때문이다.
     다행히도(?) HTTP에서도 매번 요청이 들어올 때마다 tcp 연결의 수명을 갱신하고 있어서 원하는 바를 달성한 것을 확인할 수 있었다!!
3. **MIME 타입의 `*/*;q=0`는 오해를 불러일으킨다**
   - 대개 *는 전체를 의미한다. 
     그래서인지 처음 `*/*` 타입을 봤을 때는 어떤 타입의 어떤 하위 타입이든 받아들이는 설정인 줄 알았다.
     또, `q=0`이 우선 순위를 지정하는 quality factor의 역할을 한다기에 최하위 순위에서 "어떤 응답이든 뭐라도 받겠다...!"라는 설정이라고 생각하게 되었던 것 같다.
   - 하지만 그게 아니었다는 것...ㅠ
   - `q=0`이 의미하는 것은 최하위 우선 순위이면서 선호하지 않음, 거부함의 의미를 담고 있다.
     따라서 실제 사용에서는 특정 타입과 함께 사용해서 해당 타입을 요청하고 그 이외의 타입은 전부 거부하는 용도로 사용된다.
4. **고정 사이즈의 스레드풀과 가변 사이즈의 스레드풀**
   - concurrent 패키지의 Executors를 이용해서 스레드풀을 관리할 때 여러 가지 방식으로 스레드풀을 생성할 수 있었다.
     
    | **풀 종류** | **스레드 수** | **큐 타입** | **장점** | **단점** |
    | --- | --- | --- | --- | --- |
    | FixedThreadPool | 고정 | 무제한 | 자원 제어 쉬움, 안정적 | 큐 과부하 위험 |
    | CachedThreadPool | 가변 | 없음 (즉시 실행) | 처리 속도 빠름 | 스레드 폭증 가능 |
    | SingleThreadExecutor | 1개 | 무제한 | 순차 처리 보장 | 병렬 처리 불가 |
    | ScheduledThreadPool | 고정 | 지연 큐 | 주기적 작업 처리 | 타이밍 정밀도 떨어질 수 있음 |
   - 처음에는 스레드풀을 생성할 때는 요청마다 새 스레드를 만들어서 처리할 수 있는 Cached 방식으로 풀을 생성하는 것이 좋을 것이라고 생각했다.
     하지만 오히려 요청마다 새 스레드를 만들어서 처리하는 점이 문제가 될 수도 있었다.
   - CachedThreadPool의 경우 큐가 없이 즉시 새로운 스레드를 만들어서 요청을 처리하기 때문에 만약 요청 처리 과정에서 블로킹 작업을 포함한다면
     많은 요청이 들어왔을 때 스레드가 너무 많이 생성되어서 서버에 과부하가 생길 수 있다는 것이다.
   - 이번 과제의 경우 정적 파일을 응답으로 제공하는 과정에서 IO 블로킹 작업이 포함되어 있기 때문에 CachedThreadPool 보다 FixedThreadPool을
     사용하여 구현하는 것이 더 좋을 것이라고 생각했다. 

### 오늘 하루를 통해서...
IO 자원 관리에 대해서는 제대로 고민하지 않았던 것 같은데 그룹원의 인사이트를 공유 받아서 새로운 방식으로 자원을 처리하는 방법에 대해서도 고려해볼 수 있었다.
(좋은 방법은 아니었지만 일상적으로 사용하던 방식이 왜 좋은지에 대해서 깨달을 수 있었다.) 
다른 그룹원과의 코드 공유를 통해서 스레드풀을 관리하는 방식에 대해서도 다시 생각해볼 수 있었고, 각 방식의 장단점에 대해서 알아보고 구현 방향을 정하는 과정 자체에 재미를 느낄 수 있었다. 

아무리 좋은 기술, 좋은 구조라도 본인이 그렇게 구현하는 이유를 알지 못하면 성장하지 못한다는 것을 다시금 되새기게 되었고, 
소프티어 부트캠프를 진행하는 동안 `왜?` 이렇게 구현했는지에 대해서 항상 고민하는 자세로 임해야겠다.
