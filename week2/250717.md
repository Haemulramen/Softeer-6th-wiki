# 📌 리뷰 
### 오늘 한 작업
> 미션 5단계

#### ✅ raycast 설정
- 업무 보조 툴인 raycast를 사용하여 빠르게 원하는 깃허브 페이지로 이동할 수 있도록 quickLink를 설정함.
- 백엔드 웹 서버 repository, 개인 위키 repository 설정

#### ✅ 요청의 바디가 없는 경우 오류 발생 해결
- 요청을 보냈을 때 content-length == 0인 경우 요청이 제대로 처리되지 않는 것을 확인함.
- 확인 결과 HttpRequestParser에서 바디를 읽고 UrlEncodedParser의 parse 메서드를 호출하는 과정에서 발생하는 문제였음. 구체적으로는 body 내용을 담은 String이 null인 경우만 예외를 처리하고, 비어있는 경우를 처리해주지 않아서 빈 String을 split하려는 시도에서 오류가 발생하고 있었음. 다음과 같이 if문의 조건을 추가하여 해결함.
  ```java
  if (string == null || string.isEmpty()) {
    return;
  }
  ```

#### ✅ 요청 매핑 및 처리 과정의 전반적인 구조 개선
- RequestMapper 클래스에서 단순 switch문으로 구현했던 요청 매핑과 요청 작업 수행을 분리함.
    - 함수형 인터페이스 Function을 이용해서 각 요청을 매핑하는 RequestMapper 계층
    - 각 요청의 처리 작업을 수행하는 Handler 계층
- 역할과 책임을 명확하게 분리할 수 있었고, 코드가 간결해져서 가독성도 높일 수 있었음.

#### ✅ 로그인 시 쿠키 발급, 로그아웃 시 쿠키 삭제
- 사용자가 회원가입 된 userId, password로 로그인 하는 경우 세션을 생성하고 sessionId를 쿠키로 전송한다.
- 사용자가 로그아웃하는 경우 전달 받은 쿠키를 이용해서 관리하던 세션을 삭제하고 `max-age=0` 속성을 이용해서 브라우저 스토리지의 쿠키도 만료, 삭제한다.

#### ✅ 잘못된 아이디, 비밀번호
- 사용자가 잘못된 로그인 정보로 로그인을 시도하는 경우 alert 창을 띄워서 잘못된 userId 혹은 password임을 알린다.
- 이 경우 응답은 401 Unauthorized로 한다.

### 작업 과정에서의 배운 것
#### 💡 Cookie는 단순히 name, value로 구분되는 것이 아니다.
- 로그아웃 기능을 구현하는 과정에서 로그아웃 요청을 보냈다면 클라이언트의 스토리지에 있는 쿠키도 삭제하고 싶어졌다. 쿠키를 삭제하기 위해서 해당 쿠키를 만료시켜버리면 스토리지에서 지울 수 있다는 것을 알게 되었고, 로그아웃 요청을 받았을 때 쿠키에 `max-age=0` 속성을 붙여서 응답을 전송했다.
- 하지만 로컬 스토리지에서 쿠키는 삭제되지 않았다. 찾아보니 쿠키를 식별하는 과정에서 쿠키의 이름만 사용되는 것이 아니라 path, domain도 사용되어 모두 일치해야한다는 것을 알 수 있었다.
- 쿠키는 같은 name, value를 가져도 path, domain에 따라서 다르게 전송된다는 점에 집중했다면 더 빠르게 문제를 파악할 수 있지 않았을까? 단순히 하나의 사실에 대해서만 공부하는 것이 아니라 공부한 내용을 어디서 어떻게 사용할지에 대해서도 고민해보는 것이 필요할 것 같다.

### 어려웠던 점
#### 🥊 쿠키를 어떻게 관리해야 하는가
- 미션 5단계의 로그인 기능을 구현하고 로그아웃 기능을 생각하다가 문득 여러 개의 쿠키를 주고 받는 상황에 대해서 생각해보게 되었다. 지금 내 코드에서는 `set-cookie` 필드를 하나만 헤더에 추가할 수 있는데 하나의 응답에 여러 개의 쿠키를 담아서 전송하는 경우라면 어떻게 하는 것이 적절할까?
    - HttpResponse 클래스에 List<String> cookies 필드를 추가하고 CookieBuilder 클래스를 이용해서 `set-cookie: ` 다음에 붙일 쿠키의 이름과 속성 정보를 하나씩 만들어서 해결할 수 있었다.
#### 🥊 세션을 어떻게 관리해야 하는가
- 지금 코드에서는 한 번 세션이 만들어졌을 때 로그아웃 요청을 하지 않으면 세션이 삭제되지 않고 서버에서 영원히 유지될 수 있다. 하지만 일정한 시간이 지났을 때 세션을 만료시키는 것이 필요하지 않을까?
    - Session 클래스에 만료 시간 필드를 추가하고 세션을 생성할 때 해당 필드를 초기화한다. 이후 주기적으로 스케줄링을 통해서 세션을 삭제한다. 서버에서 세션을 관리하는 나만의 청소기를 만들어서 해결할 수 있을 것 같다.


# 📌 회고 (KPT)
### Keep
- 아침 데일리 스크럼 시간을 이용해서 그룹원들과 꿀팁이나 정보를 하나씩 공유하는 시간을 가짐. AWS에서 출시한 kiro AI 툴에 대한 정보도 얻을 수 있었고, 터미널에서 사용할 수 있는 유용한 명령어 `pbcopy`에 대해서도 알 수 있었음. 앞으로도 정보 교환을 활발하게 진행하자.
- 비록 작업 내용과 의도가 명확하게 잘 전달되는 커밋 메시지 내용은 아니었지만 작은 작업 단위로 쪼개서 커밋하는 것은 전에 비해서 조금 나아진 것 같다. 앞으로도 작은 커밋을 유지하고 메시지 내용은 개선해보자.

### Problem
- 오늘 5단계 미션을 수행하고 PR을 올리면서 작업 내용을 정리하기 위해서 다시 내가 작성한 커밋 기록을 읽어봤다. 구체적으로 어떤 작업을 수행한 것인지 커밋 기록으로 떠올리는 것이 쉽지 않았다. 직접 코드와 커밋 메시지를 작성한 내가 읽어도 커밋 단위로 작업을 유추하기 힘들다면 다른 사람에게는 전혀 도움이 되지 않는 커밋일 것이다. 앞으로는 커밋을 더 자세하게 작성해야 할 필요성을 느꼈다.

### Try
- 그룹 세션 시간을 활용해서 그룹원의 코드를 보며 어떤 생각으로 작성한 코드인지 들어볼 수 있었다. 그리고 그 중 Consumer 함수형 인터페이스를 이용해서 구현한 그룹원의 코드를 볼 때 다른 그룹원으로부터 내 코드에 적용해도 좋을 것 같다는 조언을 받았다. 오후 시간 동안 적용해서 코드를 수정한 결과 역할과 책임을 분리하면서 코드의 가독성도 높일 수 있었다. 단순히 어떻게 구현했는지만 보는 것이 아니라 내 코드에도 적용해보면 좋을 것 같은 부분도 함께 생각하며 그룹 세션에 참여해야겠다.

# 📌 학습 내용
> 주말에 다시 한 번 복습하고 블로그에 정리하는 시간을 가질 키워드
#### ⚙️ 함수형 인터페이스
#### ⚙️ 쿠키의 속성
#### ⚙️ 역할과 책임의 분리
